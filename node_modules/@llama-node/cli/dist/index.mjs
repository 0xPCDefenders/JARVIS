#!/usr/bin/env node
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// ../../node_modules/.pnpm/tsup@6.7.0_typescript@5.0.4/node_modules/tsup/assets/esm_shims.js
var init_esm_shims = __esm({
  "../../node_modules/.pnpm/tsup@6.7.0_typescript@5.0.4/node_modules/tsup/assets/esm_shims.js"() {
  }
});

// src/index.ts
import {
  convert,
  LLama,
  InferenceResultType
} from "@llama-node/core";
import yargs from "yargs";
import path from "path";
import { existsSync } from "fs";
var require_src = __commonJS({
  "src/index.ts"() {
    init_esm_shims();
    var convertType = ["q4_0", "q4_1", "f16", "f32"];
    var InferenceCommand = class {
      constructor() {
        this.command = "inference";
        this.describe = "Inference LLaMA";
      }
      builder(args) {
        return args.help("help").example('llama inference -p "How are you?"', "Inference LLaMA").options("feedPrompt", {
          type: "boolean",
          demandOption: false,
          description: "Set it to true to hide promt feeding progress"
        }).options("float16", { type: "boolean", demandOption: false }).options("ignoreEos", { type: "boolean", demandOption: false }).options("nBatch", { type: "number", demandOption: false }).options("nThreads", { type: "number", demandOption: false }).options("numPredict", { type: "number", demandOption: false }).options("prompt", {
          type: "string",
          demandOption: true,
          alias: "p"
        }).options("repeatLastN", { type: "number", demandOption: false }).options("repeatPenalty", { type: "number", demandOption: false }).options("seed", { type: "number", demandOption: false }).options("temp", { type: "number", demandOption: false }).options("tokenBias", { type: "string", demandOption: false }).options("topK", { type: "number", demandOption: false }).options("topP", { type: "number", demandOption: false }).options("path", {
          type: "string",
          demandOption: true,
          alias: ["m", "model"]
        }).options("numCtxTokens", { type: "number", demandOption: false }).options("logger", {
          type: "boolean",
          demandOption: false,
          default: true,
          alias: "verbose"
        });
      }
      handler(args) {
        return __async(this, null, function* () {
          const _a = args, {
            $0,
            _,
            path: model,
            numCtxTokens,
            logger
          } = _a, rest = __objRest(_a, [
            "$0",
            "_",
            "path",
            "numCtxTokens",
            "logger"
          ]);
          const absolutePath = path.isAbsolute(model) ? model : path.join(process.cwd(), model);
          if (logger) {
            LLama.enableLogger();
          }
          const llama = LLama.create({ path: absolutePath, numCtxTokens });
          llama.inference(rest, (result) => {
            var _a2, _b;
            switch (result.type) {
              case InferenceResultType.Data:
                process.stdout.write((_b = (_a2 = result.data) == null ? void 0 : _a2.token) != null ? _b : "");
                break;
              case InferenceResultType.Error:
                console.error(result.message);
                break;
              case InferenceResultType.End:
                break;
            }
          });
        });
      }
    };
    var ConvertCommand = class {
      constructor() {
        this.command = "convert";
        this.describe = "Convert llama pth to ggml, not ready yet";
      }
      builder(args) {
        return args.help("help").example(
          "llama convert --dir ./model --type q4_0",
          "Convert pth to q4_0 ggml model"
        ).options({
          dir: {
            describe: "The directory of model and tokenizer directory",
            type: "string",
            demandOption: true
          }
        }).options({
          type: {
            describe: "The type of model",
            type: "string",
            choices: convertType,
            demandOption: true
          }
        });
      }
      handler(args) {
        return __async(this, null, function* () {
          const dir = args.dir;
          const type = args.type;
          const absolute = path.isAbsolute(dir) ? dir : path.join(process.cwd(), dir);
          if (!existsSync(absolute)) {
            console.error(`Directory ${absolute} does not exist`);
            return;
          } else {
            const elementType = convertType.findIndex((t) => t === type);
            yield convert(absolute, elementType);
            console.log("Convert successfully");
          }
        });
      }
    };
    yargs.scriptName("llama").usage("$0 <cmd> [args]").command(new ConvertCommand()).command(new InferenceCommand()).demandCommand(1, "You need at least one command before moving on").strict().parse();
  }
});
export default require_src();
//# sourceMappingURL=index.mjs.map